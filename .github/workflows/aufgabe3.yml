name: Aufgabe 3 - EC2 Deployment

on:
  push:
    branches: [ "main" ]

jobs:
  setup-ec2:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}

      - name: Create EC2 instance and install Docker
        run: |
          # Function to wait for security group to be deletable
          wait_for_sg_dependencies() {
            local sg_name=$1
            local max_attempts=30
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt of $max_attempts: Checking security group dependencies..."
              
              # Try to delete the security group
              if aws ec2 delete-security-group --group-name "$sg_name" 2>/dev/null; then
                echo "Security group deleted successfully"
                return 0
              fi
              
              echo "Security group still has dependencies. Waiting..."
              sleep 10
              ((attempt++))
            done
            
            echo "Timed out waiting for security group to be deletable"
            return 1
          }

          # Function to terminate instance with timeout
          terminate_instance() {
            local instance_id=$1
            local max_wait=300  # 5 minutes timeout
            local start_time=$(date +%s)
            
            echo "Attempting to terminate instance $instance_id..."
            
            # Verify instance exists before attempting to terminate
            if ! aws ec2 describe-instances --instance-ids "$instance_id" >/dev/null 2>&1; then
              echo "Instance $instance_id not found or already terminated"
              return 0
            fi
            
            if ! aws ec2 terminate-instances --instance-ids "$instance_id"; then
              echo "Failed to initiate termination for instance $instance_id"
              return 1
            fi
            
            while true; do
              local current_time=$(date +%s)
              local elapsed=$((current_time - start_time))
              
              if [ $elapsed -ge $max_wait ]; then
                echo "Timeout waiting for instance $instance_id termination"
                return 1
              fi
              
              # Check if instance still exists
              if ! aws ec2 describe-instances --instance-ids "$instance_id" >/dev/null 2>&1; then
                echo "Instance $instance_id no longer exists"
                return 0
              fi
              
              local state=$(aws ec2 describe-instances \
                --instance-ids "$instance_id" \
                --query 'Reservations[0].Instances[0].State.Name' \
                --output text 2>/dev/null)
                
              echo "Instance $instance_id state: $state"
              
              if [ "$state" = "terminated" ]; then
                echo "Instance terminated successfully"
                return 0
              fi
              
              sleep 10
            done
          }

          # Handle existing instances
          echo "Looking for existing instances..."
          EXISTING_INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=hello-world-instance" \
            "Name=instance-state-name,Values=running,pending,stopping,stopped" \
            --query 'Reservations[*].Instances[*].InstanceId' \
            --output text)
            
          if [ ! -z "$EXISTING_INSTANCES" ]; then
            echo "Found existing instances:"
            for INSTANCE_ID in $EXISTING_INSTANCES; do
              echo "  - $INSTANCE_ID"
              if ! terminate_instance "$INSTANCE_ID"; then
                echo "Failed to terminate instance $INSTANCE_ID, but continuing..."
              fi
            done
          else
            echo "No existing instances found."
          fi

          # Handle security group with retries
          echo "Cleaning up security group..."
          if ! wait_for_sg_dependencies "hello-world-sg"; then
            echo "Warning: Could not delete security group, but continuing..."
          fi

          # Create a security group with unique name
          TIMESTAMP=$(date +%s)
          SG_NAME="hello-world-sg-${TIMESTAMP}"
          echo "Creating security group: $SG_NAME"
          
          SECURITY_GROUP_ID=$(aws ec2 create-security-group \
            --group-name "$SG_NAME" \
            --description "Security group for hello-world app" \
            --query 'GroupId' \
            --output text)
          
          if [ -z "$SECURITY_GROUP_ID" ]; then
            echo "Error: Failed to create security group"
            exit 1
          fi
            
          echo "Created security group: $SECURITY_GROUP_ID"
          
          # Wait for security group to be available
          echo "Waiting for security group to be available..."
          sleep 5

          # Add tags to security group
          aws ec2 create-tags \
            --resources "$SECURITY_GROUP_ID" \
            --tags "Key=Name,Value=hello-world-sg"

          # Allow inbound traffic on port 8080 and SSH
          echo "Configuring security group rules..."
          aws ec2 authorize-security-group-ingress \
            --group-id "$SECURITY_GROUP_ID" \
            --protocol tcp \
            --port 8080 \
            --cidr 0.0.0.0/0
          
          aws ec2 authorize-security-group-ingress \
            --group-id "$SECURITY_GROUP_ID" \
            --protocol tcp \
            --port 22 \
            --cidr 0.0.0.0/0

          # Create a new key pair
          aws ec2 delete-key-pair --key-name hello-world-key || true
          sleep 5
          
          # Generate a local SSH key pair
          ssh-keygen -t rsa -b 2048 -f hello-world-key.pem -N ""
          chmod 400 hello-world-key.pem
          
          # Import the public key to AWS
          aws ec2 import-key-pair \
            --key-name hello-world-key \
            --public-key-material fileb://hello-world-key.pem.pub
          
          # Debug: Show the key details
          echo "Private key:"
          ls -la hello-world-key.pem
          echo "Public key:"
          cat hello-world-key.pem.pub

          # Verify security group exists
          echo "Verifying security group ID: $SECURITY_GROUP_ID"
          if [ -z "$SECURITY_GROUP_ID" ]; then
            echo "Error: Security group ID is empty"
            exit 1
          fi
          
          if ! aws ec2 describe-security-groups --group-ids "$SECURITY_GROUP_ID" >/dev/null 2>&1; then
            echo "Error: Security group $SECURITY_GROUP_ID does not exist"
            exit 1
          fi
           
          # Launch new EC2 instance with Ubuntu 22.04 LTS
          echo "Launching new EC2 instance with security group $SECURITY_GROUP_ID"
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-0261755bbcb8c4a84 \
            --instance-type t2.micro \
            --security-group-ids "$SECURITY_GROUP_ID" \
            --key-name hello-world-key \
            --user-data '#!/bin/bash
              echo "Starting user data script execution..."
              apt-get update
              apt-get install -y docker.io
              systemctl start docker
              systemctl enable docker
              usermod -aG docker ubuntu
              echo "User data script completed."' \
            --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=hello-world-instance}]' \
            --query 'Instances[0].InstanceId' \
            --output text)

          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: Failed to create instance"
            exit 1
          fi
          
          echo "New instance ID: $INSTANCE_ID"
          
          # Wait for instance to be running
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID
          
          # Give extra time for initialization
          echo "Waiting 60 seconds for full initialization..."
          sleep 60

            # Launch EC2 instance with more detailed user data
            INSTANCE_ID=$(aws ec2 run-instances \
              --image-id ami-0261755bbcb8c4a84 \
              --instance-type t2.micro \
              --security-groups hello-world-sg \
              --key-name hello-world-key \
              --user-data '#!/bin/bash
                # Redirect output to log file
                exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1
                echo "Starting user data script..."
                
                # Wait for cloud-init to complete
                echo "Waiting for cloud-init..."
                cloud-init status --wait
                
                echo "Updating system..."
                apt-get update
                apt-get install -y docker.io
                
                echo "Starting Docker..."
                systemctl start docker
                systemctl enable docker
                
                # Add ubuntu user to docker group
                usermod -aG docker ubuntu
                
                echo "User data script completed."' \
              --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=hello-world-instance}]' \
              --query 'Instances[0].InstanceId' \
              --output text)

            # Wait for instance to be running and status checks to complete
            aws ec2 wait instance-running --instance-ids $INSTANCE_ID
            aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID
            
            # Give cloud-init extra time to complete
            echo "Waiting 30 seconds for cloud-init to complete..."
            sleep 30
          fi

          # Store instance ID for later use
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          
          # Get instance public IP
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

      - name: Debug workspace
        run: |
          pwd
          ls -la
          
      - name: Upload SSH key
        uses: actions/upload-artifact@v4
        with:
          name: ssh-key
          path: hello-world-key.pem
          retention-days: 1

      - name: Verify artifact upload
        run: |
          echo "Checking if artifact was uploaded successfully"
          if [ ! -f hello-world-key.pem ]; then
            echo "Error: SSH key file not found!"
            exit 1
          fi

  deploy:
    needs: setup-ec2
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Download SSH key
        uses: actions/download-artifact@v4
        with:
          name: ssh-key
          path: .

      - name: Debug downloaded artifacts
        run: |
          pwd
          ls -la
          
      - name: Set SSH key permissions
        run: chmod 400 hello-world-key.pem

      - name: Deploy to EC2
        run: |
          # Debug: Show environment variables
          echo "Public IP: ${{ env.PUBLIC_IP }}"
          echo "Registry: ${{ steps.login-ecr.outputs.registry }}"
          
          # Get instance IP again in case env variable didn't persist
          PUBLIC_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=hello-world-instance" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          echo "Fetched Public IP: $PUBLIC_IP"
          
          if [ -z "$PUBLIC_IP" ]; then
            echo "Error: Could not get instance public IP"
            exit 1
          fi
          
          # Debug: Check SSH key
          ls -la hello-world-key.pem
          
          # Get ECR login password
          ECR_PASSWORD=$(aws ecr get-login-password)
          
          echo "Attempting to SSH to $PUBLIC_IP..."
          
          # Try to get cloud-init status via SSH
          for i in {1..5}; do
            echo "Attempt $i: Testing SSH connection..."
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i hello-world-key.pem -vvv ubuntu@$PUBLIC_IP "echo 'SSH connection successful!'"; then
              echo "SSH connection successful!"
              break
            fi
            if [ $i -lt 5 ]; then
              echo "Waiting 20 seconds before retry..."
              sleep 20
            fi
          done
          
          # SSH into instance and run container
          ssh -v -o StrictHostKeyChecking=no -i hello-world-key.pem ubuntu@$PUBLIC_IP "\
            # Login to ECR
            echo $ECR_PASSWORD | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }} && \
            # Stop and remove existing container if it exists
            docker rm -f hello-world || true && \
            # Run new container
            docker run -d --name hello-world -p 8080:8080 ${{ steps.login-ecr.outputs.registry }}/hello-world:latest"
